// Copyright 2024-2025 CSNP (csnp.org)
// SPDX-License-Identifier: Apache-2.0

package output

import (
	"errors"
	"fmt"
	"io"

	"github.com/csnp/qramm-cryptodeps/pkg/types"
)

// MarkdownFormatter formats scan results as Markdown.
type MarkdownFormatter struct {
	Options FormatterOptions
}

// Format writes the scan result as Markdown.
func (f *MarkdownFormatter) Format(result *types.ScanResult, w io.Writer) error {
	if result == nil {
		return errors.New("result cannot be nil")
	}
	if w == nil {
		return errors.New("writer cannot be nil")
	}
	// Title
	fmt.Fprintf(w, "# CryptoDeps Scan Report\n\n")

	// Summary
	fmt.Fprintf(w, "## Summary\n\n")
	fmt.Fprintf(w, "| Metric | Value |\n")
	fmt.Fprintf(w, "|--------|-------|\n")
	fmt.Fprintf(w, "| **Manifest** | `%s` |\n", result.Manifest)
	fmt.Fprintf(w, "| **Ecosystem** | %s |\n", result.Ecosystem)
	fmt.Fprintf(w, "| **Total Dependencies** | %d |\n", result.Summary.TotalDependencies)
	fmt.Fprintf(w, "| **Using Crypto** | %d |\n", result.Summary.WithCrypto)
	fmt.Fprintf(w, "| **Quantum Vulnerable** | %d |\n", result.Summary.QuantumVulnerable)
	fmt.Fprintf(w, "| **Quantum Partial** | %d |\n", result.Summary.QuantumPartial)
	fmt.Fprintf(w, "| **Not in Database** | %d |\n", result.Summary.NotInDatabase)
	fmt.Fprintf(w, "\n")

	// Check if there are any crypto findings
	hasCrypto := false
	for _, dep := range result.Dependencies {
		if dep.Analysis != nil && len(dep.Analysis.Crypto) > 0 {
			hasCrypto = true
			break
		}
	}

	if !hasCrypto {
		fmt.Fprintf(w, "No cryptographic usage detected in dependencies.\n")
		return nil
	}

	// Findings by risk level
	fmt.Fprintf(w, "## Findings\n\n")

	// Collect remediation for detailed section
	remediationMap := make(map[string]string) // algorithm -> remediation

	// Vulnerable
	fmt.Fprintf(w, "### Quantum Vulnerable\n\n")
	hasVulnerable := false
	for _, dep := range result.Dependencies {
		if dep.Analysis == nil {
			continue
		}
		for _, crypto := range dep.Analysis.Crypto {
			if crypto.QuantumRisk == types.RiskVulnerable {
				if !hasVulnerable {
					fmt.Fprintf(w, "| Dependency | Algorithm | Type | Severity |\n")
					fmt.Fprintf(w, "|------------|-----------|------|----------|\n")
					hasVulnerable = true
				}
				fmt.Fprintf(w, "| %s@%s | %s | %s | %s |\n",
					dep.Dependency.Name,
					dep.Dependency.Version,
					crypto.Algorithm,
					crypto.Type,
					crypto.Severity,
				)
				if crypto.Remediation != "" {
					remediationMap[crypto.Algorithm] = crypto.Remediation
				}
			}
		}
	}
	if !hasVulnerable {
		fmt.Fprintf(w, "No quantum-vulnerable algorithms found.\n")
	}
	fmt.Fprintf(w, "\n")

	// Partial
	fmt.Fprintf(w, "### Quantum Partial Risk\n\n")
	hasPartial := false
	for _, dep := range result.Dependencies {
		if dep.Analysis == nil {
			continue
		}
		for _, crypto := range dep.Analysis.Crypto {
			if crypto.QuantumRisk == types.RiskPartial {
				if !hasPartial {
					fmt.Fprintf(w, "| Dependency | Algorithm | Type | Severity |\n")
					fmt.Fprintf(w, "|------------|-----------|------|----------|\n")
					hasPartial = true
				}
				fmt.Fprintf(w, "| %s@%s | %s | %s | %s |\n",
					dep.Dependency.Name,
					dep.Dependency.Version,
					crypto.Algorithm,
					crypto.Type,
					crypto.Severity,
				)
				if crypto.Remediation != "" {
					remediationMap[crypto.Algorithm] = crypto.Remediation
				}
			}
		}
	}
	if !hasPartial {
		fmt.Fprintf(w, "No partial-risk algorithms found.\n")
	}
	fmt.Fprintf(w, "\n")

	// Remediation Guidance
	if f.Options.ShowRemediation && len(remediationMap) > 0 {
		fmt.Fprintf(w, "## Remediation Guidance\n\n")
		fmt.Fprintf(w, "| Algorithm | Recommended Action |\n")
		fmt.Fprintf(w, "|-----------|--------------------|\n")
		for algo, remediation := range remediationMap {
			fmt.Fprintf(w, "| **%s** | %s |\n", algo, remediation)
		}
		fmt.Fprintf(w, "\n")
	}

	// NIST PQC Standards Reference
	fmt.Fprintf(w, "## NIST Post-Quantum Cryptography Standards\n\n")
	fmt.Fprintf(w, "| Standard | Algorithm | Use Case |\n")
	fmt.Fprintf(w, "|----------|-----------|----------|\n")
	fmt.Fprintf(w, "| [FIPS 203](https://csrc.nist.gov/pubs/fips/203/final) | ML-KEM (Kyber) | Key Encapsulation |\n")
	fmt.Fprintf(w, "| [FIPS 204](https://csrc.nist.gov/pubs/fips/204/final) | ML-DSA (Dilithium) | Digital Signatures |\n")
	fmt.Fprintf(w, "| [FIPS 205](https://csrc.nist.gov/pubs/fips/205/final) | SLH-DSA (SPHINCS+) | Stateless Hash Signatures |\n")
	fmt.Fprintf(w, "\n")

	// Notes section for packages not in database
	if result.Summary.NotInDatabase > 0 {
		fmt.Fprintf(w, "## Notes\n\n")
		pct := float64(result.Summary.NotInDatabase) / float64(result.Summary.TotalDependencies) * 100
		fmt.Fprintf(w, "> **%d packages (%.0f%%) were not in the crypto database.**\n", result.Summary.NotInDatabase, pct)
		fmt.Fprintf(w, "> Run with `--deep` flag to analyze these packages via source code inspection.\n\n")
	}

	// Footer
	fmt.Fprintf(w, "---\n\n")
	fmt.Fprintf(w, "*Generated by [CryptoDeps](https://github.com/csnp/qramm-cryptodeps) - Part of the [QRAMM Toolkit](https://qramm.org)*\n")

	return nil
}

// FormatMulti writes multi-project scan results as Markdown.
func (f *MarkdownFormatter) FormatMulti(result *types.MultiProjectResult, w io.Writer) error {
	if result == nil {
		return errors.New("result cannot be nil")
	}
	if w == nil {
		return errors.New("writer cannot be nil")
	}

	// Title
	fmt.Fprintf(w, "# CryptoDeps Multi-Project Scan Report\n\n")

	// Overview
	fmt.Fprintf(w, "## Overview\n\n")
	fmt.Fprintf(w, "| Metric | Value |\n")
	fmt.Fprintf(w, "|--------|-------|\n")
	fmt.Fprintf(w, "| **Root Path** | `%s` |\n", result.RootPath)
	fmt.Fprintf(w, "| **Projects Scanned** | %d |\n", len(result.Projects))
	fmt.Fprintf(w, "| **Total Dependencies** | %d |\n", result.TotalSummary.TotalDependencies)
	fmt.Fprintf(w, "| **Using Crypto** | %d |\n", result.TotalSummary.WithCrypto)
	fmt.Fprintf(w, "| **Quantum Vulnerable** | %d |\n", result.TotalSummary.QuantumVulnerable)
	fmt.Fprintf(w, "| **Quantum Partial** | %d |\n", result.TotalSummary.QuantumPartial)
	fmt.Fprintf(w, "\n")

	// Project list
	fmt.Fprintf(w, "### Projects\n\n")
	for _, project := range result.Projects {
		fmt.Fprintf(w, "- `%s` (%s)\n", project.Manifest, project.Ecosystem)
	}
	fmt.Fprintf(w, "\n")

	// Individual project reports
	for _, project := range result.Projects {
		fmt.Fprintf(w, "---\n\n")
		fmt.Fprintf(w, "## %s\n\n", project.Manifest)

		// Use the single-project formatter for detailed output
		if err := f.Format(project, w); err != nil {
			return err
		}
	}

	return nil
}
